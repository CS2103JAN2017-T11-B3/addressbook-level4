# A0164212U
###### /java/seedu/task/commons/core/Messages.java
``` java
    public static final String MESSSAGE_INVALID_TIMING_ORDER = "The start and end times are not in chronological order";

}
```
###### /java/seedu/task/commons/exceptions/IllegalTimingOrderException.java
``` java
package seedu.task.commons.exceptions;

/**
 * Signals that start timing is after end timing.
 */
public class IllegalTimingOrderException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalTimingOrderException(String message) {
        super(message);
    }
}
```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String priority, String startTiming, String endTiming,
            String recurFreq, Set<String> tags)
                    throws IllegalValueException, IllegalTimingOrderException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        boolean recurring = (recurFreq != null);

        this.toAdd = new Task(
                new Description(name),
                new Priority(priority),
                new Timing(startTiming),
                new Timing(endTiming),
                new UniqueTagList(tagSet),
                recurring,
                new RecurringFrequency(recurFreq)
                );

        if (!Timing.checkTimingOrder(toAdd.getStartTiming(), toAdd.getEndTiming())) {
            throw new IllegalTimingOrderException(MESSSAGE_INVALID_TIMING_ORDER);
        }
    }
```
###### /java/seedu/task/model/ModelManager.java
``` java
        /**
         * @param task
         * internally sets task.occurrenceIndexList for occurrences that match given keywords for task
         * @return true if keywords are present in the given task
         */
        @Override
        public boolean run(ReadOnlyTask task) {
            boolean isValid = false;
            ArrayList<Integer> occurrenceIndexList = new ArrayList<Integer>();
            for (int i = 0; i < task.getOccurrences().size(); i++) {
                final int finalIndex = i;
                if (
                        (nameKeyWords.stream()
                                .filter(keyword -> StringUtil.containsWordIgnoreCase(
                                        task.getDescription().description, keyword))
                                .findAny()
                                .isPresent()) ||
                        (nameKeyWords.stream()
                                .filter(keyword -> StringUtil.containsWordIgnoreCase(
                                        task.getPriority().value, keyword))
                                .findAny()
                                .isPresent()) ||
                        (nameKeyWords.stream()
                                .filter(keyword -> StringUtil.containsWordIgnoreCase(
                                        task.getOccurrences().get(finalIndex).getStartTiming().value, keyword))
                                .findAny()
                                .isPresent()) ||
                        (nameKeyWords.stream()
                                .filter(keyword -> StringUtil.containsWordIgnoreCase(
                                        task.getOccurrences().get(finalIndex).getEndTiming().value, keyword))
                                .findAny()
                                .isPresent())) {
                    occurrenceIndexList.add(i);
                    isValid = true;
                }
            }
            task.setOccurrenceIndexList(occurrenceIndexList);
            return isValid;
        }
```
###### /java/seedu/task/model/task/Priority.java
``` java
package seedu.task.model.task;

import seedu.task.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's priority number in the address book.
 * A smaller priority number indicates a higher priority.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should be between 1-3";

    public final String value;

    private String priorityColor;

    /**
     * Validates given priority number.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        if (priority != null) {
            String trimmedPriority = priority.trim();
            if (!isValidPriority(trimmedPriority)) {
                throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
            }
            this.value = trimmedPriority;
        } else {
            this.value = "3";
        }

        setPriorityColor(this.value);
    }

    /**
     * Returns true if a given string is a valid task priority.
     */
    public static boolean isValidPriority(String test) {
        return (test.equals("1") || test.equals("2") || test.equals("3"));
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                        && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public String getPriorityColor() {
        return priorityColor;
    }

    public void setPriorityColor(String priorityValue) {
        switch(priorityValue) {
        case "1":
            priorityColor = "red";
            break;
        case "2":
            priorityColor = "darkorange";
            break;
        case "3":
            priorityColor = "yellow";
            break;
        default:
            priorityColor = "yellow";
            break;
        }
    }
```
###### /java/seedu/task/model/task/RecurringFrequency.java
``` java
package seedu.task.model.task;

import seedu.task.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's frequency in the ToDo list.
 * Guarantees: immutable; is valid as declared in {@link #isValidFrequency(String)}
 */
public class RecurringFrequency {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS =
            "Frequency must be a number followerd by h, d, m (no spaces)";

    public static final String FREQUENCY_VALIDATION_REGEX = "^[0-9]+[hdmHDM]";
    public static final String NULL_FREQUENCY = "0";

    public final String frequency;

    public static final int HOUR_LIMIT = 168; //one week
    public static final int DAY_LIMIT = 60; //two months
    public static final int MONTH_LIMIT = 12; //one year

    /**
     * Validates given frequency.
     *
     * @throws IllegalValueException if given frequency string is invalid.
     */
    public RecurringFrequency(String frequency) throws IllegalValueException {
        if (frequency != null) {
            String trimmedFrequency = frequency.trim();
            if (!isValidDescription(trimmedFrequency)) {
                throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
            }
            this.frequency = trimmedFrequency;
        } else {
            this.frequency = NULL_FREQUENCY;
        }
    }

    /**
     * Returns true if a given string is a valid frequency.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(FREQUENCY_VALIDATION_REGEX) || test.equals(NULL_FREQUENCY);
    }

    @Override
    public String toString() {
        return frequency;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RecurringFrequency // instanceof handles nulls
                        && this.frequency.equals(((RecurringFrequency) other).frequency)); // state check
    }

    @Override
    public int hashCode() {
        return frequency.hashCode();
    }

    public int getFrequencyNumber() {
        String numberOnlyString = frequency.replaceAll("[^0-9]", "");
        int numberOnly = Integer.parseInt(numberOnlyString);
        return numberOnly;
    }

    public String getFrequencyCharacter() {
        String characterOnly = frequency.replaceAll("[^A-Za-z]", "");
        return characterOnly;
    }
}
```
###### /java/seedu/task/model/task/RecurringTask.java
``` java
//package seedu.task.model.task;
//
//import java.text.SimpleDateFormat;
//import java.util.ArrayList;
//import java.util.Calendar;
//import java.util.Objects;
//
//import seedu.task.commons.exceptions.IllegalValueException;
//import seedu.task.commons.util.CollectionUtil;
//import seedu.task.model.tag.UniqueTagList;
//
///**
// * Represents a Task in the ToDo List. Guarantees: details are present and not
// * null, field values are validated.
// */
//public class RecurringTask implements ReadOnlyTask {
//
//    private Description description;
//    private Priority priority;
//    private UniqueTagList tags;
//    private RecurringFrequency frequency;
//
//    private ArrayList<RecurringTaskOccurrence> occurrences;
//
//    /**
//     * Every field must be present and not null.
//     */
//    public RecurringTask(Description description, Priority priority, Timing startTiming,
//                          Timing endTiming, UniqueTagList tags, RecurringFrequency frequency) {
//        assert !CollectionUtil.isAnyNull(description, priority, startTiming, tags, frequency);
//        this.description = description;
//        this.priority = priority;
//        this.tags = new UniqueTagList(tags); // protect internal tags from
//        // changes in the arg list
//        this.frequency = frequency;
//        this.occurrences = new ArrayList<RecurringTaskOccurrence>();
//        setOccurences(this.frequency, startTiming, endTiming);
//
//    }
//
//    /**
//     * Creates a copy of the given ReadOnlyTask.
//     */
//    public RecurringTask(ReadOnlyTask source) {
//        this(source.getDescription(), source.getPriority(), source.getStartTiming(), source.getEndTiming(),
//                source.getTags(), source.getFrequency());
//    }
//
//    public void setDescription(Description description) {
//        assert description != null;
//        this.description = description;
//    }
//
//    @Override
//    public Description getDescription() {
//        return description;
//    }
//
//    public void setPriority(Priority priority) {
//        assert priority != null;
//        this.priority = priority;
//    }
//
//    @Override
//    public Priority getPriority() {
//        return priority;
//    }
//
//    @Override
//    public UniqueTagList getTags() {
//        return new UniqueTagList(tags);
//    }
//
//    /**
//     * Replaces this task's tags with the tags in the argument tag list.
//     */
//    public void setTags(UniqueTagList replacement) {
//        tags.setTags(replacement);
//    }
//
//    @Override
//    public RecurringFrequency getFrequency() {
//        return frequency;
//    }
//    public ArrayList<RecurringTaskOccurrence> getOccurrences() {
//        return occurrences;
//    }
//
//    public SimpleDateFormat retriveFormat(String s) {
//        SimpleDateFormat format;
//        if (s.length() <= 10) {
//            format = new SimpleDateFormat("dd/MM/yyyy");
//        } else {
//            format = new SimpleDateFormat("HH:mm dd/MM/yyyy");
//        }
//        return format;
//    }
//
//    /** If frequency is in hours - support up to 168 hours (1 week)
//     * If frequency is in weeks - support up to 24 weeks
//     * If frequency is in months - support up to 12 months
//     * @param frequency
//     * @param startTime
//     * @param endTime
//     */
//    public void setOccurences(RecurringFrequency frequency, Timing initialStartTime, Timing initialEndTime) {
//        int freqNumber = frequency.getFrequencyNumber();
//        String freqCharacter = frequency.getFrequencyCharacter();
//        Calendar cal1 = Calendar.getInstance();
//        Calendar cal2 = Calendar.getInstance();
//        cal1.setTime(initialStartTime.getTiming());
//        cal2.setTime(initialEndTime.getTiming());
//        SimpleDateFormat startTimeFormat = retriveFormat(initialStartTime.toString());
//        SimpleDateFormat endTimeFormat = retriveFormat(initialEndTime.toString());
//        String tempStartTime, tempEndTime;
//        Timing tempStart = null, tempEnd = null;
//        RecurringTaskOccurrence occurenceToAdd;
//
//        switch (freqCharacter) {
//        case "h":
//            for (int i = 0; i < RecurringFrequency.HOUR_LIMIT; i += freqNumber) {
//                cal1.add(Calendar.HOUR_OF_DAY, freqNumber);
//                cal2.add(Calendar.HOUR_OF_DAY, freqNumber);
//                tempStartTime = startTimeFormat.format(cal1.getTime());
//                tempEndTime = endTimeFormat.format(cal2.getTime());
//                try {
//                    tempStart = new Timing(tempStartTime);
//                } catch (IllegalValueException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                try {
//                    tempEnd = new Timing(tempEndTime);
//                } catch (IllegalValueException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                occurenceToAdd = new RecurringTaskOccurrence(tempStart, tempEnd);
//                occurrences.add(occurenceToAdd);
//            }
//            break;
//        case "d":
//            for (int i = 0; i < RecurringFrequency.DAY_LIMIT; i += freqNumber) {
//                cal1.add(Calendar.DATE, freqNumber);
//                cal2.add(Calendar.DATE, freqNumber);
//                tempStartTime = startTimeFormat.format(cal1.getTime());
//                tempEndTime = endTimeFormat.format(cal2.getTime());
//                try {
//                    tempStart = new Timing(tempStartTime);
//                } catch (IllegalValueException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                try {
//                    tempEnd = new Timing(tempEndTime);
//                } catch (IllegalValueException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                occurenceToAdd = new RecurringTaskOccurrence(tempStart, tempEnd);
//                occurrences.add(occurenceToAdd);
//            }
//            break;
//        case "m":
//            for (int i = 0; i < RecurringFrequency.MONTH_LIMIT; i += freqNumber) {
//                cal1.add(Calendar.MONTH, freqNumber);
//                cal2.add(Calendar.MONTH, freqNumber);
//                tempStartTime = startTimeFormat.format(cal1.getTime());
//                tempEndTime = endTimeFormat.format(cal2.getTime());
//                try {
//                    tempStart = new Timing(tempStartTime);
//                } catch (IllegalValueException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                try {
//                    tempEnd = new Timing(tempEndTime);
//                } catch (IllegalValueException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                occurenceToAdd = new RecurringTaskOccurrence(tempStart, tempEnd);
//                occurrences.add(occurenceToAdd);
//            }
//            break;
//        }
//    }
//
//    /**
//     * Updates this task with the details of {@code replacement}.
//     */
//    public void resetData(ReadOnlyTask replacement) {
//        assert replacement != null;
//
//        this.setDescription(replacement.getDescription());
//        this.setPriority(replacement.getPriority());
//        this.setOccurences(replacement.getFrequency(), replacement.getStartTiming(), replacement.getEndTiming());
//        this.setTags(replacement.getTags());
//    }
//
//    @Override
//    public boolean equals(Object other) {
//        return other == this // short circuit if same object
//                || (other instanceof ReadOnlyTask // instanceof handles nulls
//                        && this.isSameStateAs((ReadOnlyTask) other));
//    }
//
//    @Override
//    public int hashCode() {
//        // use this method for custom fields hashing instead of implementing
//        // your own
//        return Objects.hash(description, priority, getStartTiming(), getEndTiming(), tags);
//    }
//
//    @Override
//    public String toString() {
//        return getAsText();
//    }
//
//
//    //returns initial start time
//    @Override
//    public Timing getStartTiming() {
//        return getOccurrences().get(0).getStartTiming();
//    }
//
//    //returns initial start time
//    @Override
//    public Timing getEndTiming() {
//        return getOccurrences().get(0).getEndTiming();
//    }
//
//    @Override
//    public boolean isComplete() {
//        return getOccurrences().get(0).isComplete();
//    }
//
//    @Override
//    public boolean isRecurring() {
//        return true;
//    }
//}
```
###### /java/seedu/task/model/task/RecurringTaskOccurrence.java
``` java
package seedu.task.model.task;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.commons.util.CollectionUtil;

public class RecurringTaskOccurrence {
    private Timing startTiming;
    private Timing endTiming;
    private boolean complete;

    public RecurringTaskOccurrence(Timing startTime, Timing endTime) {
        assert !CollectionUtil.isAnyNull(startTime, endTime);
        this.startTiming = startTime;
        this.endTiming = endTime;
        this.complete = false;
    }

    public RecurringTaskOccurrence() throws IllegalValueException {
        this(new Timing(Timing.getTodayDate()), new Timing(Timing.getTodayDate()));
    }

    public Timing getStartTiming() {
        return startTiming;
    }

    public void setStartTiming(Timing startTime) {
        assert startTime != null;
        this.startTiming = startTime;
    }

    public Timing getEndTiming() {
        return endTiming;
    }

    public void setEndTiming(Timing endTime) {
        assert endTime != null;
        this.endTiming = endTime;

    }

    public void setComplete(boolean complete) {
        this.complete = complete;
    }

    public boolean isComplete() {
        return complete;
    }
}
```
###### /java/seedu/task/model/task/Task.java
``` java
package seedu.task.model.task;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Objects;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.commons.util.CollectionUtil;
import seedu.task.model.tag.UniqueTagList;

/**
 * Represents a Task in the ToDo List. Guarantees: details are present and not
 * null, field values are validated.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {

    private Description description;
    private Priority priority;
    private ArrayList<RecurringTaskOccurrence> occurrences;
    private boolean recurring;
    private UniqueTagList tags;
    private RecurringFrequency frequency;
    private ArrayList<Integer> occurrenceIndexList = new ArrayList<Integer>();

    /**
     * Every field must be present and not null.
     */
    public Task(Description description, Priority priority, Timing startTiming, Timing endTiming,
            UniqueTagList tags, boolean recurring, RecurringFrequency frequency) {
        assert !CollectionUtil.isAnyNull(description, priority, startTiming, tags);
        this.description = description;
        this.priority = priority;
        this.occurrences = new ArrayList<RecurringTaskOccurrence>();
        this.tags = new UniqueTagList(tags); // protect internal tags from
        // changes in the arg list
        this.recurring = recurring;
        this.frequency = frequency;
        setOccurrences(startTiming, endTiming);
        occurrenceIndexList.add(0);
    }

    public Task(Description description, Priority priority, ArrayList<RecurringTaskOccurrence> occurrences,
            UniqueTagList tags, boolean recurring, RecurringFrequency frequency) {
        assert !CollectionUtil.isAnyNull(description, priority, occurrences, tags, recurring, frequency);
        this.description = description;
        this.priority = priority;
        this.occurrences = occurrences;
        this.tags = new UniqueTagList(tags);
        this.recurring = recurring;
        this.frequency = frequency;
    }


    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getDescription(), source.getPriority(), source.getOccurrences(),
                source.getTags(), source.isRecurring(), source.getFrequency());
    }

    @Override
    public ArrayList<Integer> getOccurrenceIndexList() {
        return occurrenceIndexList;
    };

    @Override
    public void setOccurrenceIndexList(ArrayList<Integer> list) {
        occurrenceIndexList = list;
    };

    public void setDescription(Description description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    @Override
    public void setStartTiming(Timing startTiming) {
        assert startTiming != null;
        this.occurrences.get(0).setStartTiming(startTiming);
    }

    @Override
    public Timing getStartTiming(int i) { //add parameter to index into correct endTime
        return this.occurrences.get(i).getStartTiming();
    }

    @Override
    public Timing getStartTiming() {
        return getStartTiming(0);
    }

    @Override
    public void setEndTiming(Timing endTiming) { //add parameter to index into correct endTime
        assert endTiming != null;
        this.occurrences.get(0).setEndTiming(endTiming);
    }

    @Override
    public Timing getEndTiming() {
        return this.occurrences.get(0).getEndTiming();
    }

    public void setComplete() { //add parameter to index into correct endTime
        this.occurrences.get(0).setComplete(true);
    }

    @Override
    public boolean isComplete() { //add parameter to index into correct endTime
        return this.occurrences.get(0).isComplete();
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setDescription(replacement.getDescription());
        this.setPriority(replacement.getPriority());
        //        this.setStartTiming(replacement.getStartTiming());
        //        this.setEndTiming(replacement.getEndTiming());
        this.setOccurrences(replacement.getOccurrences());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(description, priority,
                occurrences.get(0).getStartTiming(), occurrences.get(0).getEndTiming(),
                tags, recurring, frequency);
    }

    @Override
    public RecurringFrequency getFrequency() {
        return frequency;
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean isRecurring() {
        return recurring;
    }

    public void setRecurring(boolean recurring) {
        this.recurring = recurring;
    }

    @Override
    public ArrayList<RecurringTaskOccurrence> getOccurrences() {
        return occurrences;
    }

    public SimpleDateFormat retriveFormat(String s) {
        SimpleDateFormat format;
        if (s.length() <= 10) {
            format = new SimpleDateFormat("dd/MM/yyyy");
        } else {
            format = new SimpleDateFormat("HH:mm dd/MM/yyyy");
        }
        return format;
    }

    public void setOccurrences(ArrayList<RecurringTaskOccurrence> occurrences) {
        this.occurrences = occurrences;
    }

    /** If frequency is in hours - support up to 168 hours (1 week)
     * If frequency is in weeks - support up to 24 weeks
     * If frequency is in months - support up to 12 months
     * @param startTime
     * @param endTime
     */
    public void setOccurrences(Timing initialStartTime, Timing initialEndTime) {
        this.occurrences.add(new RecurringTaskOccurrence(initialStartTime, initialEndTime));
        if (isRecurring()) {
            int freqNumber = frequency.getFrequencyNumber();
            String freqCharacter = frequency.getFrequencyCharacter();
            Calendar cal1 = Calendar.getInstance();
            Calendar cal2 = Calendar.getInstance();
            cal1.setTime(initialStartTime.getTiming());
            cal2.setTime(initialEndTime.getTiming());
            SimpleDateFormat startTimeFormat = retriveFormat(initialStartTime.toString());
            SimpleDateFormat endTimeFormat = retriveFormat(initialEndTime.toString());
            String tempStartTime;
            String tempEndTime;
            Timing tempStart = null;
            Timing tempEnd = null;
            RecurringTaskOccurrence occurrenceToAdd;
            switch (freqCharacter) {
            case "h":
                for (int i = 1; i < RecurringFrequency.HOUR_LIMIT; i += freqNumber) {
                    cal1.add(Calendar.HOUR_OF_DAY, freqNumber);
                    cal2.add(Calendar.HOUR_OF_DAY, freqNumber);
                    tempStartTime = startTimeFormat.format(cal1.getTime());
                    tempEndTime = endTimeFormat.format(cal2.getTime());
                    try {
                        tempStart = new Timing(tempStartTime);
                    } catch (IllegalValueException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    try {
                        tempEnd = new Timing(tempEndTime);
                    } catch (IllegalValueException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    occurrenceToAdd = new RecurringTaskOccurrence(tempStart, tempEnd);
                    occurrences.add(occurrenceToAdd);
                }
                break;
            case "d":
                for (int i = 1; i < RecurringFrequency.DAY_LIMIT; i += freqNumber) {
                    cal1.add(Calendar.DATE, freqNumber);
                    cal2.add(Calendar.DATE, freqNumber);
                    tempStartTime = startTimeFormat.format(cal1.getTime());
                    tempEndTime = endTimeFormat.format(cal2.getTime());
                    try {
                        tempStart = new Timing(tempStartTime);
                    } catch (IllegalValueException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    try {
                        tempEnd = new Timing(tempEndTime);
                    } catch (IllegalValueException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    occurrenceToAdd = new RecurringTaskOccurrence(tempStart, tempEnd);
                    occurrences.add(occurrenceToAdd);
                }
                break;
            case "m":
                for (int i = 1; i < RecurringFrequency.MONTH_LIMIT; i += freqNumber) {
                    cal1.add(Calendar.MONTH, freqNumber);
                    cal2.add(Calendar.MONTH, freqNumber);
                    tempStartTime = startTimeFormat.format(cal1.getTime());
                    tempEndTime = endTimeFormat.format(cal2.getTime());
                    try {
                        tempStart = new Timing(tempStartTime);
                    } catch (IllegalValueException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    try {
                        tempEnd = new Timing(tempEndTime);
                    } catch (IllegalValueException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    occurrenceToAdd = new RecurringTaskOccurrence(tempStart, tempEnd);
                    occurrences.add(occurrenceToAdd);
                }
                break;
            default:
                break;
            }
        }
    }

```
###### /java/seedu/task/model/task/Timing.java
``` java
package seedu.task.model.task;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import seedu.task.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's timing in the address book. Guarantees: immutable; is valid
 * as declared in {@link #isValidTiming(String)}
 */
public class Timing implements Comparable<Timing> {

    public static final String MESSAGE_TIMING_CONSTRAINTS =
            "Task timing should be in the format HH:mm dd/MM/yyyy OR dd/MM/yyyy " +
                    "Use only HH:mm if today is the default date";
    public static final String[] TIMING_FORMAT = {"HH:mm dd/MM/yyyy", "dd/MM/yyyy"};
    public static final String NULL_TIMING = "floating";
    public final String value;
    private Date timing;

    /**
     * Validates given timing.
     * Sets today's date as default if only time is specified
     *
     * @throws IllegalValueException
     *             if given timing string is invalid.
     */
    public Timing(String time) throws IllegalValueException {
        if (time != null) {
            String trimmedTiming = time.trim();
            if (!trimmedTiming.equals(NULL_TIMING) && trimmedTiming.length() <= 5) {
                trimmedTiming = trimmedTiming + " " + Timing.getTodayDate();
            }
            if (!isValidTiming(trimmedTiming)) {
                throw new IllegalValueException(MESSAGE_TIMING_CONSTRAINTS);
            }
            this.value = trimmedTiming;
            setTiming(trimmedTiming);
        } else {
            this.value = NULL_TIMING;
            this.timing = null;
        }
    }

    public Timing() throws IllegalValueException {
        this(null);
    }

    /**
     * Returns if a given string is a valid timing.
     */
    public static boolean isValidTiming(String test) {
        boolean isValid = false;
        if (test.equals(NULL_TIMING)) {
            isValid = true;
        } else {
            for (int i = 0; i < TIMING_FORMAT.length; i++) {
                SimpleDateFormat sdf = new SimpleDateFormat(TIMING_FORMAT[i]);
                sdf.setLenient(false);
                try {
                    // throws ParseException if timing is not valid
                    Date date = sdf.parse(test);
                    // check if year is truly 4 digits (the 'yyyy' regex does not support this)
                    Calendar cal = Calendar.getInstance();
                    cal.setTime(date);
                    if (cal.get(Calendar.YEAR) >= 1000 && cal.get(Calendar.YEAR) <= 9999) {
                        isValid = true;
                    }
                    break;
                } catch (ParseException e) {
                }
            }
        }
        return isValid;
    }

    public void setTiming(String time) {
        for (int i = 0; i < TIMING_FORMAT.length; i++) {
            SimpleDateFormat sdf = new SimpleDateFormat(TIMING_FORMAT[i]);
            sdf.setLenient(false);
            try {
                // throws ParseException if timing is not valid
                Date date = sdf.parse(time);
                this.timing = date;
                break;
            } catch (ParseException e) {
            }
        }
    }

    public Date getTiming() {
        return timing;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        if (this.value == null) {
            return false;
        }
        return other == this // short circuit if same object
                || (other instanceof Timing // instanceof handles nulls
                        && this.value.equals(((Timing) other).value)); // state
        // check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    /**
     * @return returns today's date as a string in "dd/MM/yyyy" format
     */
    public static String getTodayDate() {
        DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
        Date date = new Date();
        String dateString = dateFormat.format(date);
        return dateString;
    }

    /**
     *
     * @param time1
     * @param time2
     * @return returns True if time1 is before time2
     */
    public static boolean checkTimingOrder(Timing time1, Timing time2) {
        boolean isOrdered = true;
        if (time1 == null || time1.value.equals(NULL_TIMING)
                || time2 == null || time2.value.equals(NULL_TIMING)) {
            return isOrdered;
        }
        Calendar cal1 = Calendar.getInstance();
        Calendar cal2 = Calendar.getInstance();
        cal1.setTime(time1.getTiming());
        cal2.setTime(time2.getTiming());

        if (cal1.compareTo(cal2) > 0) {
            isOrdered = false;
        }

        return isOrdered;
    }

```
###### /java/seedu/task/ui/PersonCard.java
``` java
    @FXML
    private Label description;
    @FXML
    private Label id;
    @FXML
    private Label priority;
    @FXML
    private Label startTiming;
    @FXML
    private Label endTiming;
    @FXML
    private Label recurring;
    @FXML
    private FlowPane tags;

    public PersonCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        description.setText(task.getDescription().description);
        id.setText(displayedIndex + ". ");
        priority.setText("Priority: " + task.getPriority().value);
        priority.setStyle("-fx-background-color: " + task.getPriority().getPriorityColor() + ";");

        if (task.getStartTiming().value.equals(Timing.NULL_TIMING)) {
            startTiming.setText("");
        } else if (task.getOccurrenceIndexList().size() == 0) {
            startTiming.setText("Start Timing: " + task.getOccurrences().get(0).getStartTiming().value);
        } else {
            int index = task.getOccurrenceIndexList().get(0);
            startTiming.setText("Start Timing: " + task.getOccurrences().get(index).getStartTiming().value);
        }

        if (task.getEndTiming().value.equals(Timing.NULL_TIMING)) {
            endTiming.setText("");
        } else if (task.getOccurrenceIndexList().size() == 0) {
            endTiming.setText("End Timing: " + task.getOccurrences().get(0).getEndTiming().value);
        } else {
            int index = task.getOccurrenceIndexList().get(0);
            endTiming.setText("End Timing: " + task.getOccurrences().get(index).getEndTiming().value);
        }

        if (task.isRecurring()) {
            recurring.setText("Recurring Task: " + task.getFrequency().toString());
            recurring.setStyle("-fx-background-color: pink;");
        } else {
            recurring.setText("");
        }
        initTags(task);
    }
```
###### /resources/view/PersonListCard.fxml
``` fxml
                        <FlowPane fx:id="tags" />
                        <Label fx:id="priority" styleClass="cell_small_label" text="\$priority" />
                        <Label fx:id="startTiming" styleClass="cell_small_label" text="\$startTiming" />
						<Label fx:id="endTiming" styleClass="cell_small_label" text="\$endTiming" />
						<Label fx:id="recurring" styleClass="cell_small_label" text="\$recurring" />
```
###### /resources/view/PersonListCard.fxml
``` fxml
                    </children>
                </VBox>
            </children>
        </GridPane>
    </children>
</HBox>
```
